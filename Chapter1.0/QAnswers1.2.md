Q1. Cadence supports itself on Safety and Security, code Clarity, Approachability, Developer Experience while setting itself as Resource Oriented Programming language.

Q2. Cadence is used to build applications that can, potentially, deal with significant sums of money, even if just as cryptocurrency. This increases the risks associated to bugs and inefficient code exponentially. A bug in a frontend application can lead to an unpleasant experience. In a backend application can result in wasted time and computational resources. But in a smart contract? It can ruin a person or company financially, hence why Security and Safety should be so paramount in blockchain applications.
Code Clarity is another of those elements that was only important to other developers in centralized (server-client) applications, but it takes a new, more important role in the new world of decentralized applications. Transparency and trust are fundamental for the acceptance of blockchain technology by the larger public. Unfortunately, this same public is also largely ignorant regarding computer science and code development in general. There are little advantages in promoting your code as open source if everyone can see it, but no one can understand it. If we are moving into a world where it is expected that some users (maybe not all) are capable of looking at the code of a deployed contract in a blockchain and determine its validity (with other users using that "assurance" as a tacit OK to execute it), it is important that the programming language in which the contract is written is as clear as possible for everyone, and not just to experienced developers.
Switching programming languages as a developer should be like driving a different car. You may struggle a bit at first, getting used to the new brake sensibility, where all the buttons and levers now are, but in the end, fundamentally, it is still a car: ignition, driving wheel, gas and brake are always on the same place and should work the same way (unless you go to the UK, Japan, or South Africa…). Everything else is accessory and should not hinder you from reaching your destination. The same should be true for programming languages to keep developers flexible and, honestly, to keep things interesting, hence why code Accessibility is so important, especially when new languages are popping up as mushrooms lately.
In my opinion, the 4th pillar intersects the 3rd a little bit. Taking advantage of a developer's experience is obviously important, if not just to have experienced professionals switching to your tool, which is a useful endorsement for any new computational tool. Therefore, it is logic that you should keep the culture shock to a minimum (also because older, more experienced developers tend to be bit set on their ways) to increase the acceptability of the new language by the people that can validate it the most. But honestly, this notion goes very much in line with was already said the previous point.
Finally, I simply love the "Resource Oriented Programming", especially for the old heads like me that learned how to code on Object Oriented Programming, the main gospel in code writing not so long ago. Blockchain and this distributed programming paradigm are so different, so transformative regarding the current technological landscape that it’s only fair that it gets its own paradigm too. Personally, programming my first smart contracts was a very different experience than, say, moving from SOAP webservices to cloud functions and such. I had to change my way of thinking in a way that no other programming language or context did in the past. It’s very refreshing and it’s definitely one of the reasons why I want to know that Flow and Cadence are about.
